<div class="page-data" style="display: none;" data-page-info='{"title": "Правила игры программирования Gridwars"}'></div>
<div class="back-block">
    <a href="/<%= language -%>/article">
        &lt Статьи
    </a>
</div>
<h1>
    Правила игры программирования Gridwars
</h1>

<h3>Правила игры</h3>
<p>
Поле боя представляет собой прямоугольную сетку, каждая ячейка которой может быть либо пустой, либо занята одним из
роботов. Ячейка, занятая роботом окрашивается в его цвет и имеет идентификатор владельца ячейки. Цель игры – захватить
все поле, одолев других роботов. Победа засчитывается так же, если робот останется на поле боя один, например, если
другой робот был дисквалифицирован.
</p>
<img width="320" height="322" src="/css/grid.gif" />
<p>
Ячейки игрока на каждом шаге обрабатываются алгоритмом. Для каждой ячейки исполняется алгоритм, в результате работы
которого должно быть принято решение о том в какие из соседних ячеек будут произведены выстрелы. Процесс игры
состоит из множества шагов, на каждом из которых роботы делают выстрелы из своих ячеек. После того как все
отстреляются, среда, в которой запущены искусственные интеллекты роботов, делает анализ данных о выстрелах на
основании которого определяет новые захваченные ячейки. Каждая ячейка хранит в себе 32 битное слово, в котором
может быть записано что угодно. Вычисление нового значения 32 битного слова происходит на этапе выстрела. Свежие,
только захваченные ячейки будут иметь пустое 32 битное слово.
</p>
<p>
Алгоритм получает информацию о соседях-ячейках – это массив, каждый из элементов которого может хранить номер
вражеского робота, 32 битное слово, если этот сосед свой или ноль, если ячейка пустая. У ячейки есть 3 выстрела.
Выстрелы могут быть произведены как для захвата новой территории, так и для поддержки своих ячеек. Для захвата
ячейки требуется, чтобы в нее было произведено как минимум 3 выстрела. Если в эту же ячейку стреляли на некотором
ходу другие роботы, то захватывает тот, кто выстрелил большее количество раз, но как минимум 3 раза. Если
устанавливается несколько лидеров на захват ячейки, то есть несколько воинов имеют одно и то же количество
выстрелов в ячейку и при этом это количество максимальное, то такая ячейка не будет захвачена ни одним из них,
остается прежней.
</p>

<h3>Правила программирования робота</h3>
<p>
Робот реализуется через JavaScript функцию, получающую на вход массив значений, определяющих окружающие ячейки,
и возвращающих на выходе массив из четырех значений: первые три — это номера ячеек в которые производится выстрел,
последнее значение — это новое 32 битное слово-строка, которое будет определять эту ячейку для ячеек
вашего робота на следующем шаге. Так же роботу нужно дать уникальное имя на этапе регистрации робота.
</p>
<p>
Каждый  элемент массива значений, поступающего единственным входным параметром в функцию, — это либо строка
(32 битное слово) либо число (номер робота) противника либо ноль, если клетка пуста. Очередность значения
в массиве определяет положение ячейки относительно текущей. Массив значений включает в себя девять элементов.
</p>
<p>
Нумеруется набор соседних ячеек следующим образом.
</p>
<img width="200" height="200" src="/css/cell-numbers.gif">
<p>
Как во входном массиве номер-позиция — это индекс массива, по которому будет извлечен элемент, так и на выходном
массиве первые три элемента массива — числа, номера-позиции, куда будут сделаны выстрелы, относительно текущей ячейки.
В том числе можно обратиться к значению текущей ячейки — под индексом 4, пятый элемент входного массива.
Причем нельзя стрелять в текущую ячейку, т.е. выстрел в позицию 4 (индекс текущей клетки) будет определён как
не валидный и робот будет дисквалифицирован или не пройдет валидацию еще на этапе регистрации.
</p>
<p>
32 битное слово представляется строкой из 32 символов (0 или 1) типа String. Номер вражеского робота или пустая
ячейка представляется числом типа Number.
</p>
<p>
На каждом шаге для каждой ячейки вашего робота будет выполнена написанная вами функция с передачей в нее актуальных значений.
</p>
<p>
Робот регистрируется вызовом метода register. Первым параметром в него передается функция, описанная выше,
вторым имя робота — строка. На этапе регистрации файл с регистрацией будет проверен на соответствие такой регулярке:
/^global.register\([\S\s]*\);$/. Т.е. файл по большому счету должен содержать только вызов метода регистрации,
в который должна быть передана анонимная функция и строка. Это сделано для того, чтобы ограничить возможность
создания некого скопа переменных в рамках робота. Вызов анонимных функций так же запрещен, на это делается
специальная проверка. Поэтому не будет возможности извлечь функцию для параметра регистрации, через вызов
анонимной функции.
</p>
<p>
Каждый робот выполняется в песочнице, где отключены многие возможности JavaScript, многие глобальные, общедоступные
в браузере или при разработке в NodeJS. Итого в песочнице доступен следующий функционал:
</p>
<pre><code class="javascript">Number; String; parseInt;
parseFloat; Object; Array;
Math;
</code></pre>
<p>
Так же на этапе регистрации робота будут произведены проверки на предмет использования некоторых возможностей JavaScript.
Это сделано в целях безопасности для того, чтобы ограничить пользователя в доступе к глобальным ресурсам системы через
JavaScript трюк. Итак, будут сделаны следующие проверки:
</p>
<p>
Соответствие /^global.register\([\S\s]*\);$/. Подробно описано выше.
</p>
<p>
Отсутствие вызова/обращения к eval. Для невозможности выполнения строки-кода.
</p>
<p>
Отсутствие вызова/обращения к Function, window,  document,  parent, top, call, apply, constructor, caller, prototype.
</p>
<p>
Постарайтесь обойтись в принципе без использования этих слов, даже как начальной части какого-либо наименования.
В этих случаях такой робот будет забракован на этапе регистрации.
</p>
<p>
Так же запрещен вызов функций без указания контекста или вызов ананимной функции.
Все функции следует использовать подобным образом:
</p>
<pre><code class="javascript">var newLib = {
    foo1 : function () { // … },
    foo2 : function () { // … },
    foo3 : function () { // … }
};
fooLib.fooMethod(fooObject, newLib.foo1);</code></pre>
<p>
    Иное использование функций будет забраковано на этапе регистрации.
</p>
<p>
При регистрации проверяется, что робот был передан в функцию register, первый параметр — функция,
второй параметр — имя робота, строка. В случае несоответствия вам будет сообщено об этом.
</p>
<p>
Так же программа проверяется на то, что программа работает, не зависает и производит вычисления выстрелов достаточно
быстро. Верхний допустимый предел установлен 100 мс на выстрел на этапе проверки. Однако это достаточно медленно,
старайтесь уложиться в несколько миллисекунд на вычисление ответа, так ваш робот будет работать быстро и будет
популярным на арене.
</p>
<p>
После написания вами файла с алгоритмом его можно загрузить на странице <a href="/<%= language -%>/profile">профайла</a>.
Чтобы получить доступ к этой возможности следует
<a href="/<%= language -%>/register">зарегистрироваться</a> и <a href="/<%= language -%>/login">авторизоваться</a> на сайте.
</p>
<p>
Далее следует пример кода формального робота.
Такой робот стреляет все три выстрела в случайную клетку из соседних клеток
и генерирует случайное валидное 32 битное слово, что будет представлять текущую
ячейку на следующем ходу своим соседям.
</p>
<pre><code class="javascript">global.register(function (comvarSet) {
    var warrior = {
        shoot : function (comvarSet) {
            // ....
            var shoot1 = parseInt(Math.random() * 8, 10),
                result;

            if (shoot1 === 4) {
                shoot1++;
            }

            var myLib = {
                generateNewComvar : function () {
                    var index,
                        result = '';
                    for (index = 0; index < 32; index++) {
                        result += String(parseInt(Math.random() * 2, 10));
                    }
                    return result;
                }
            }
            result = [shoot1, shoot1, shoot1, myLib.generateNewComvar()];
            return result;
        }
    };
    return warrior.shoot(comvarSet);
}, "exampleFighter");</code></pre>

<%- partial('./github-code-examples') %>
